---
layout: lab
title: Lab 2 - HPC and Command Line BLAST
hidden: true
---

# Outline:
- Automation in Unix
- Intro to using a computer cluster
- Running BLAST from the command line
- Running more complex BLAST jobs

# Projects
- After the tutorials today, there will hopefully be time to work on your database projects. The projects are due next Thursday in Lecture. In lecture, you will each be expected to give a short (3-5 minute) presentation of your database to your group. We'll then collect and summarize the range of databases you explore as a class.


# Unix tutorial

In Lab 1, we covered commands to move around the Unix file system. These included:

- `pwd`: List the current working directory
-  `cd`: Change to a new directory
-  `ls`: list files, folders, and programs
-  `man`: view the help page for a program

We also covered the basic structure of a unix command:

`command -argument input_file > output_file`

These commands are summarized in the file: [Unix commands cheatsheat]({{ site.baseurl }}{% post_url supplements/2017-09-27-unix_commands %})

Today, we will continue this tutorial. We will focus on how to automate actions in Unix. This includes:

- wild cards
- scripts
- for loops

We will also cover some other useful commands including:

- `cat`, `echo`, `mv`
- `head`, `tail`, `less`, `wc`


## Refresher activity

Open the data-shell directory in `Git BASH`. Type:

```
ls -F
```

There is a folder called `Desktop`. Inside it is a folder called `hidden`. Somewhere inside that folder is a file called `youfoundit.txt`. Find the file. Once you've found it, enter the command:

```
cat youfoundit.txt
```

The command `cat` takes as input a file name, and simply reads the file and prints its output to the screen.

## Automation-1

Now, we'll return to processing Nelle's data files using the `goostats` program.

Return to the `data_shell` directory, and then go to the `north-pacific-gyre/2012-07-03` folder.

Remember, the command to process a file looks like:

```
programs/goostat NENE01729A.txt > output_NENE01729A.txt
```

Process the first three files: `NENE01729A.txt`, `NENE01729B.txt`, and `NENE02040A.txt`. Use the `up-arrow` to repeat the previous command, and then the arrow keys to modify it. You can open the folder in Windows File-Explorer to see the output files. Or type `ls -F`.

### Cleaning up our mess

Note that with these output files, our data directory is getting messy. It would be nicer to have the raw data files in one folder and the output files in another folder.

Let's make an output folder, and move our output files there. On Windows, you could create a new directory. In BASH, type:

```
mkdir output
```

On Windows, you could select each file and drag it to the folder. In BASH, type:

```
mv output_NENE01729A.txt output/
```

You can also re-name files with the `mv` command:

```
mv output/output_NENE01729B.txt output/renamed_file.txt
```

**Note**: We didn't have to move to the `output` directory to do this renaming. We just gave the relative path to the file.

#### Wildcards

Remember, BASH is all about automation. We don't have to type the `mv` command for each file separately. We can use a wild-card to select all the output files at once:

``` 
mv output* output/
```

The `*` character matches any set of character. Before running the `mv` command, BASH first expands `output*` to all files that start with `output`, and then contain 0 or more additional characters. It then passes them all to mv command.

**Hint** There's no `UNDO` in BASH! It's always a good idea to test out a BASH command like this before you run it. Before running a command, you can use the command `echo` to print out exactly what BASH is going to do:

```
echo "mv output* output/"
```

Be sure to put the command in quotes.

`echo` is similar to `cat`, except for commands instead of files. `cat` prints the contents of the file to the screen. `echo` prints the command itself to the screen.

```
echo "Some text"
echo "output*"
```

You don't always need the quotes, but it's a good habid.

Wildcards work with many commands. Try it with `ls`:

```
ls -F NENE*
```

### Activity:
Find all files that have the character `A` in them. How many are there?

**Before continuing, all output files should be in the output folder.**

## Automation-2

Wildcards are one way to automate. Scripts are another.

Run `goostat` again, but this time write directly into the `output` folder.

Remember the command? You can find it by typing `history`.

1. Open `Notepad++`. Copy the comand, paste it there
2. Paste it several times
3. Replace the file name with the others in the directory.
4. Copy it all, paste it in terminal.
5. Is this easier? No. **But it's documented!**
6. Alternatively, save it as `process_goostats.sh`. **Be sure to change character encoding to Unix**.
7. Run with `bash process_goostats.sh`

### For-loops

But, we can tell Bash to automate the creation of each of these lines.

Computers are great a repetitive tasks like this. They do it faster, with fewer mistakes.

A **for loop** is a tool for repeating the same action several times with a different input each time.

```
for file in *.txt
do
  programs/goostat $file > output/output_$file
done
```

The loop has several parts:

1. `for file in *.txt`: This declares the loop and the input for each iteration.
	2. `*.txt` gives a list of files. We can view the list with `echo *.txt`. Lists in Bash are separate by spaces
	3. `file` is a **variable**. What the loop will do is it will take the name of the first file from the list, and assign it to the variable `file`. It will then run the lines between `do` and `done`. Once those lines are done, it will assign the next file name to the variable `file`.
	4. Inside the `do/done` block, we can refer to the actual file name by typing `$file`, or better `${file}`. When bash sees `$file`, it replaces it with the file name stored in the variable.
	4. Do: `file=NENE01729A.txt`, and then `echo $file`. Try `echo file`.
	5. Now, do: `file=some_other_file.txt`, and then `echo $file`.

Before we run the script, let's test it. Replace the line `program...` with `echo "program..."`. Then copy the lines and paste into the terminal. 

**This just wrote out exactly what we were trying to do by hand!** We could copy these lines. We could copy these lines into a new script, and then run it with `bash process_all.sh`. But, instead, if we just remove the `echo`, and run the loop, it will send these lines directly to the Bash engine and execute them!

Do this, then run the script with `bash process_goostats.sh`

### Make a nicer script.

Scripts are both a tool for automation, and also a tool for documentation. If you write your scripts well, they both save you time now, and also help when you come back later and want to do the same or similar actions again, or when you have to write up your methods.

We can do several things to make this script nicer. 

1. Add comments. You can write lines in your script that begin with the hash character `#`. Bash will ignore these lines:
```
# echo some text
```
2. We can add a line that tells us what the computer is currently doing:
```
echo "Currently processing file $file"
```

### Activity:

Write a script to process all pairs of files using the program `goodiff`. Concatenate the output into one file that looks like:

|  |  |  |
|-------|-------|-------|
| file1 | file2 | score |
| file1 | file3 | score |
| file2 | file3 | score |

Hints:

Everything that shows up on the screen can be written instead to a file. Try and compare these lines:

```
# using echo
echo "my text"
echo "my text" > my_file.txt

# using cat
cat my_file.txt
cat my_file.txt > new_file.txt
cat new_file.txt
cat my_file.txt >> new_file.txt
cat new_file.txt
```

**Note:** 

- A single ">" says: "create a new file with this name and capture the output into this file".
- Two ">>" says: "append the output to the end of the existing file (and create a new file if needed)"


## Things to remember:

- Bash identifies separate arguments to commands by spaces. This means that spaces in file names cause problems
	- This is why you should enclose commands in quotation marks `"`. Things in quotation marks are interpreted as being part of the same argument

1. In Notepad++, create a file called `My File.txt`. Put some text in it.
2. In Bash, type: `cat My File.txt`. You get an error
3. Try: `cat "My File.txt"`. It works!
4. Try: `file="My File.txt"`, and then `cat $file`. You get an error.
5. Try `cat "$file"`. It works!


Other helpful commands:

- `wc file` Counts the number of lines, words, and characters in a file
- `head file` Prints the first 10 lines of a file. You can change the number with the `-n 3` option (replacing 3 with the number you want.
- `tail file` Prints the last 10 lines of a file.
- `less file` Gives an interactive view of the file. You can page-down using space or the arrow keys. To exit, type `q`. The `man` command uses `less` to show the help file for each command.


# Intro to High Performance Computing

### Key ideas:

- The Farm cluster is a **shared resource**. It is important to follow some rules so that you do not interfere with other users.
- The Farm cluster has a head node and then a bunch of compute nodes
	- You log in from your computer to the head node, and then ask for time on a compute node. 
	- You have to move files from your computer to the cluster. Once there, the whole file system is shared among all nodes. You don't need to keep copying files
	- The cluster runs Linux (clone of Unix). You control it using Bash
	- There are lots of programs installed, and different versions of many programs. Use `modules` to select which programs you want to use. It takes care of the rest.
	- You can log in to Farm from anywhere as long as you have your username / password. This will be given to you (it's not your Kerberos login).

### Log in:
To log in, from a Unix terminal type:

```
ssh username@farm.cse.ucdavis.edu
```

Then enter your password. You will arrive at your personal **home directory**, which will be: `/home/username`. Only you can write / modify files in this directory.

### Directories:
There is a class directory called: `/group/BIT150`. You can access these files, but they are locked - you cannot change them. If you want to share files with the class, you can put them in: `/group/BIT150/Share`. Change to each of these directories (using `cd`), and view their contents (using `ls`).

### Moving files on and off:
Open the `FileZilla` program. This program sets up a secure connection to the Farm file server and lets you move files on and off of the cluster. It works a lot like `Windows File Explorer`.

To use:

1. Select new site, enter: Host: `farm.cse.ucdavis.edu`, Port: `2022`, Protocol: `SFTP`, Logon Type: "Normal", User: `username`, Password: `password`, Click `Connect`.
2. On the left is a file explorer for your computer. Navigate to the `Z:/Classes/BIT150/Lab_2`.
3. On the right is a file explorer for Farm's file system. Create a directory called `Lab_2`. You can also do this in the terminal (`mkdir Lab_2`).
4. Find the file: `brac1.fasta`, and drag it onto Farm.
5. In the terminal, enter the command: `echo Some Text > new_file.txt`. In `FileZilla`, refresh the Farm file explorer. The file `new_file.txt` should appear. Double-click, or drag it to your computer.


## Running BLAST	

The BLAST programs are installed on Farm. They are fairly intensive programs, requiring a moderate amount of RAM, and sometimes a lot of time to run. 

**We do not want to run BLAST on the head node!** This could bog-down this computer and prevent others on the cluster from doing their work!

First, request an allocation on one of the compute nodes:

### Requesting an interactive job
```
srun -p bit150 -t 20 --pty bash -l
```
- `srun` is a command that asks for an allocation
- `-p bit150` asks to use the `bit150` partition. This means use the resources assigned to our class
- `-t 20` asks for 20 minutes. After this time, your allocation will shut down
- `--pty bash -l` asks for the allocation to run `Bash` just as if you opened a new terminal

Hit `Enter`, and then wait a minute. Eventually you will see some messages saying you are logged in to a job.

To see info on your job, type:
```
squeue -u username
```

### The blast program

Now that we have access to a powerful computer, we can use BLAST to search a database for our sequence.

Our sequence is in the file `myoD.fasta`, the file we moved to Farm. View the file with:

```
head myoD.fasta
```

#### Question: Is this a nucleotide of protein sequence?

### The FASTA format

The FASTA	format is a common format for storing sequence files. Each sequence has a header (**the metadata**), and then the sequence. The header is the first line, and begins with the `>` character. The rest of the line contains various annotations (a very compressed version of the GenBank format). Longer sequences are split over multiple lines. But the line breaks are irrelevant. Programs like BLAST know to keep reading the sequence until the end of the file. 

Multiple sequences can be held in the same file. They are separated by header lines.

First, we have to load the module with the blast program. The bio module includes many bioinformatics programs. Type:

```
module load bio
```

Now, we can run blast. A run looks like this:

```
blastp -db /group/BIT150/blast_databases/refseq_H_sapiens_protein/refseq_human_protein -query myoD.fasta -out myoD_blast.txt
```

- `blastp` is the program for protein-protein blast.
- `db /group/BIT150/blast_databases/refseq_H_sapiens_protein/refseq_human_protein` specifies the blast database that we want to use. We select the `refseq_human_protein ` database in the `/group/BIT150/blast_databases/refseq_H_sapiens_protein/` directory
- `query myoD.fasta` specifies the query sequence
- `out myoD_blast.txt ` specifes we want the output stored in the file called `myoD_blast.txt `

Look at the file. It's long. A good viewer is `less`. Or, you can download it to your computer using `FileZilla`, and view it in `Notepad++`.

Let's modify the command. We can change the output style into a concise table. Rather than re-typing, use the up-arrow to get find the command. **Note:** or, you could use `history`. Now, instead of moving the cursor with the arrow keys, copy it to a Notepad++ document, and edit it there.

For clarity, it's often nice to break up long commands into several lines. You can do this by putting a `\` character at the end of each line.

```
blastp  \
   -db /group/BIT150/blast_databases/refseq_H_sapiens_protein/refseq_human_protein \
   -query myoD.fasta \
   -out myoD_blast_table.txt \
   -outfmt 6   
```

I added the option `-outfmt 6`. This changes the format of the output to a table. See `blastp -help` for more formatting options.

You can copy this whole set of code and paste into the terminal. Now, look at this output file using `less`.

When you're done, exit the compute node by typing:

```
exit
```

**Always remember to exit when you're done - this frees up resources for others!**

#### Notes:

- There are many more options for the `blastp` program. You can view them with `blastp -help`, or [here](https://www.ncbi.nlm.nih.gov/books/NBK279675/)
- There are many databases that you could blast against. You can also create your own starting with a file of fasta sequences using the `makeblastdb` command. [Link](https://www.ncbi.nlm.nih.gov/books/NBK279688/)
- You can extract sequences from a database with the `blastdbcmd` program [Link](https://www.ncbi.nlm.nih.gov/books/NBK279689/)


## Running longer jobs with sbatch

The `srun` command is useful for testing commands and shorter programs. But it has limitations for longer or more intensive jobs.

- Sometimes it takes a long time to get an allocation. With `srun` you have to wait.
- With `srun`, you have to wait until your program is done and then remember to log out.

The preferred way to run computation on a cluster like Farm is by submitting jobs that run **non-interactively** using the command `sbatch`.

Launching a `sbatch` job looks like this:

```
sbatch -p bit150 -t 30 my_script.sh
```

This will tell the cluster to find a time to allocate resources to my job for 30 minutes, and then run the script `my_script.sh`

The key to using `sbatch` is writing a good script. The body of the script is the set of commands you would type in to Bash if you were there to control it. But you start the script with some special commands to tell the cluster how to run your job. 

The simplest script looks like this:

```
#!/bin/bash

module load bio

blastp  \
   -db /group/BIT150/blast_databases/refseq_H_sapiens_protein/refseq_human_protein \
   -query myoD.fasta \
   -out myoD_blast_table.txt \# some comment \
   -outfmt 6    
```

- The first line tells the cluster to run this script with the `bash` shell.
- The second tells it to load the bio module
- Then we give the command for running blast.

We can then modify this script to do longer, more intensive jobs:

The following script does a blast using a query file that includes 10 different sequences:

```
#!/bin/bash

module load bio

blastp  \
   -db /group/BIT150/blast_databases/refseq_H_sapiens_protein/refseq_human_protein \
   -query /group/BIT150/Lab_2/mouse_protein_set1.fasta \
   -out mouse_protein_set1_blast_table.txt \
   -outfmt 6    
```

## Modular scripts
The above script is fine, but it is a bit hard to read, and is also hard to modify. Say you wanted to blast a different gene against a different database? How would you change the script?

The way to write cleaner scripts is to use bash variables. We saw variables earlier when writing for loops. The concept here is the same. We can assign a **value** to a **variable** in the top of the script, and then use the variable later:

```
#!/bin/bash

module load bio

# declare database and query files
database=/group/BIT150/blast_databases/refseq_H_sapiens_protein/refseq_human_protein
query=/group/BIT150/Lab_2/mouse_protein_set1.fasta
output_file=mouse_protein_set1_blast_table.txt

blastp  \
   -db $database \
   -query $query \
   -out mouse_protein_set1_blast_table.txt \
   -outfmt 6
```

Now the call to `blastp` is much clearer. It's also often helpful to separate directories from file names, and base names from file extensions. A better script might look like this:
 
```
#!/bin/bash

module load bio

# declare database directory
database_dir=/group/BIT150/blast_databases/

# declare input file directory
query_dir=/group/BIT150/Lab_2

# declare output file directory
output_dir=.

# database
database=refseq_human_protein

# query
query=mouse_protein_set1

blastp  \
   -db $database_dir/$database \
   -query $query_dir/${query}.fasta \
   -out $output_dir/${query}_blast_table.txt \
   -outfmt 6
```

### Activities

1. Modify the above script to blast the `mouse_protein_set1.fasta` file against these three databases:

```
refseq_human_protein
refseq_mouse_protein
refseq_zebrafish_protein
refseq_plant_protein
swissprot
```

2. Modifying the above script, write a **for loop** to blast each of the files in `/group/BIT150/Lab_2/individual_genes`, saving each in it's own file in an output directory of your home directory?

## Notes

When submitting `sbatch` jobs, two important commands are:

- `squeue -p bit150`, or `squeue -u bit150-01`. These show you if your job is running
- `scancel -u bit150-01`. This cancels all your running jobs. You can also do: `scancel 15968444` to cancel a specific job numer


# Homework:
1. Find the amino acid sequence of your gene
2. Choose three of the blast databases on Farm. Here is a list:
>
| Database                 | Type    | program  |
|--------------------------|---------|----------|
|`refseq_human_protein`     | Protein | blastp   |
|`refseq_mouse_protein`     | Protein | blastp   |
|`refseq_zebrafish_protein` | Protein | blastp   |
|`refseq_plant_protein`     | Protein | blastp   |
|`swissprot`                | Protein | blastp   |
|`Cdd_NCBI`                 | Domains | rpsblast |
|`Pfam`                     | Domains | rpsblast |
| `Smart`                   | Domains | rpsblast |

3. Write a script to BLAST your sequence against these three databases. Note that the last three are databases of protein domains. These require the `rpsblast` program instead of `blastp`

4. Now, go to NCBI's blast server and run the same searches there. Compare the results. 
5. Write a Markdown document describing what you learned about your gene. Include your script from step 3.

